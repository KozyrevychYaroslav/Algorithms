package ai181.kozyrevych;

public class QuickSort {

    public static void sort(int[] nums) {
        qs(nums, 0, nums.length - 1);
    }

    private static void qs(int[] nums, int left, int right) {
        int i = left;
        int j = right;
        int x;
        x = nums[(left + right) / 2];

        do {
            while ((nums[i] < x)) i++;
            while ((nums[j] > x)) j--;

            // благодаря x < nums[j] если x меньше всех чисел с лева, то когда
            // nums[j] дойдет до проверки равенства с самим собой, цикл прекратится, так как x будет = nums[j]
            // i - индекс числа с левой части которое больше того которое посередине
            // j - индекс числа с правой части, которое меньше того которое посередине
            // в условии i <= j а не i < j, так как во втором случае если средний элемент будет равен i-тому элементу и при этом
            // у нас будет ровно 2 элемента суммарно в текущем подмассиве, то в  if (i < right) qs(nums, i, right); получится бесконечный цикл
            // так как right всегда будет больше i так как right это индекс последнего элемента подмассива
            // а если написать  i <= j, то когда i будет равен j, то он увеличится на единицу и станет равен right и соответственно в if получится false
            // помимо этого когда i и j равны и у нас условие  i<=j, то мы в подмассивы не передаем лишние элементы, так как i становится правее j, а j левее i,
            // в ином же случае элемент по середине был бы и в левом подмассиве и  в правом
            // если убрать вообще условие if, то иногда бывает такое что элемент i заходит дальще j, а если i зашло дальше j
            // то элементы на этих индексах менять местами нет смысла (так как они уже правильно отсортированы)
            if (i <= j) {

                // после обмена значениями, число слева будет меньше числа посередине, а число справа больше числа посередине
                swap(nums, i, j);

                //если не проиндексировать i и j то получится бесконечный цикл, потому что если и слева и справа будут
                // элементы равные среднему элементу, они поменяются местами, но при этом в while циклах мы будем
                //сразу же выходить из них, так как элементы равны среднему а должны быть либо меньше либо больше среднего
                // помимо этого если мы поменяли элементы местами, нам нет смысла снова их сравнивать с средним элементом
                // так как они на правильном месте относительно него
                i++;
                j--;
            }
        } while (i < j);


        //если j > left значит есть такой элемент слева, который больше j (либо же массив еще не до конца просмотрен)
        //а значит нужно произвести сортировку этой части
        if (j > left) qs(nums, left, j);

        if (i < right) qs(nums, i, right);
    }

    private static void swap(int[] nums, int i, int j) {
        int y = nums[i];
        nums[i] = nums[j];
        nums[j] = y;
    }

}
